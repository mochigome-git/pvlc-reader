package main

import (
	"embed"
	"fmt"
	"log"
	"net"
	"net/http"
	"os"
	"os/signal"
	"runtime"
	"strings"
	"sync"
	thd "testcode/pkg"
	"time"

	"github.com/fsnotify/fsnotify"
	"github.com/joho/godotenv"
	"github.com/zserge/lorca"
)

// Declare global variables to hold the database connection details
var (
	host     string
	port     string
	user     string
	password string
	dbname   string
	pcName   string
	dirname  string
)

//go:embed www
var fs embed.FS

// Go types that are bound to the UI must be thread-safe because each binding
// is executed in its own goroutine. In this simple case, we may use atomic
// operations, but for more complex cases one should use proper synchronization.
type counter struct {
	sync.Mutex
	count int
}

var (
	contentMutex sync.Mutex
	contentReady bool
	content      string
	contentCond  *sync.Cond
)

var (
	contentCh = make(chan string)
)

func setContents(value string) {
	contentCh <- value
}

func waitForContentsReady() (string, bool) {
	contents := <-contentCh
	return contents, true
}

func getContents() (string, bool) {
	contentMutex.Lock()
	defer contentMutex.Unlock()
	return content, contentReady
}

func pickLog(filePattern string, fileInfo thd.LogFileInfo) (string, error) {
	filePath := fileInfo.Path
	fileName := fileInfo.Name
	findStr := "read: "

	// Create a channel to receive the log contents
	logContentCh := make(chan string)
	errCh := make(chan error)

	// Start a goroutine to read the log contents
	go func() {
		contents, err := thd.GetLog(fileName, findStr, filePath)
		if err != nil {
			errCh <- fmt.Errorf("error getting log: %w", err)
			return
		}
		logContentCh <- contents
	}()

	// Wait for the log contents or an error
	select {
	case contents := <-logContentCh:
		//fmt.Println(contents)
		return contents, nil
	case err := <-errCh:
		return "", err
	}
}

func logWatcherLoop() {
	fileInfoCh := make(chan thd.LogFileInfo)
	filePattern := time.Now().Format("2006_01_02") + "*.log"

	go thd.StartLogWatcher(filePattern, fileInfoCh)

	// Loop continuously to process log files
	go func() {
		for {
			fileInfo := <-fileInfoCh
			logContent, err := pickLog(filePattern, fileInfo)
			if err != nil {
				log.Println("error getting log:", err)
				continue
			}
			//fmt.Println(logContent)

			// Update the contents using the setter function
			setContents(logContent)
		}
	}()
}

func fsnotifyStart(counterCallback func(string)) {
	log.Println("監視開始", dirname)

	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Println("error creating watcher:", err)
		return
	}
	defer watcher.Close()

	done := make(chan bool)

	// Start a separate goroutine to handle the thd.Insert operation
	go func() {
		for {
			contents := <-contentCh

			if !strings.Contains(contents, "Init Programming") && strings.Contains(contents, "verified") {
				sig, err := thd.Insert(host, port, user, password, dbname, pcName, contents)
				if err != nil {
					log.Println("error inserting data:", err)
				}
				counterCallback(sig) // Call the completion callback
			}
		}
	}()

	go func() {
		for {
			select {
			case event := <-watcher.Events:
				log.Println("event:", event)
				switch {
				case event.Op&fsnotify.Write == fsnotify.Write:
					// Get the latest contents
					contents, contentsReady := getContents()
					if !contentsReady {
						// Contents not ready, wait until it becomes available
						contents, contentsReady = waitForContentsReady()
					}

					fmt.Println(contents)

					// Update the contents using the setter function
					setContents(contents)

				case event.Op&fsnotify.Create == fsnotify.Create:
					// Get the latest contents
					contents, contentsReady := getContents()
					if !contentsReady {
						// Contents not ready, wait until it becomes available
						contents, contentsReady = waitForContentsReady()
					}

					if contentsReady {
						// Update the contents using the setter function
						setContents(contents)
					}
				}
			case err := <-watcher.Errors:
				log.Println("error:", err)
				done <- true
			}
		}
	}()

	err = watcher.Add(dirname)
	if err != nil {
		log.Println("error adding watcher:", err)
		return
	}
	<-done
}

func main() {
	// Load the configuration from the environment file
	err := godotenv.Load(".env")
	if err != nil {
		log.Println("error loading configuration from .env file:", err)
	}

	// Read the configuration from environment variables
	host = os.Getenv("DB_HOST")
	port = os.Getenv("DB_PORT")
	user = os.Getenv("DB_USER")
	password = os.Getenv("DB_PASSWORD")
	dbname = os.Getenv("DB_NAME")
	pcName = os.Getenv("PC_NAME")
	dirname = os.Getenv("DIR_NAME")

	// Start the log watcher loop
	logWatcherLoop()

	args := []string{}
	if runtime.GOOS == "linux" {
		args = append(args, "--class=Lorca")
	}
	ui, err := lorca.New("", "", 780, 620, "--remote-allow-origins=*")
	if err != nil {
		log.Println("runtime error:", err)
	}
	defer ui.Close()

	ui.Bind("start", func() {
		log.Println("UI is ready")
	})

	c := &counter{}
	ui.Bind("counterAdd", c.Add)
	ui.Bind("counterValue", c.Count)
	ui.Bind("NotifyStart", func() {
		fsnotifyStart(func(sig string) {
			ui.Eval(`window.NotifyStartComplete("` + sig + `")`)
		})
	})
	ui.Bind("saveConfigGo", thd.SetConfig)
	ui.Bind("loadConfigGo", thd.LoadConfigGo)

	ln, err := net.Listen("tcp", "127.0.0.1:0")
	if err != nil {
		log.Println("listen tcp error:", err)
	}
	defer ln.Close()
	go http.Serve(ln, http.FileServer(http.FS(fs)))
	ui.Load(fmt.Sprintf("http://%s/www", ln.Addr()))

	sigc := make(chan os.Signal)
	signal.Notify(sigc, os.Interrupt)
	select {
	case <-sigc:
	case <-ui.Done():
	}

	log.Println("exiting...")
}

func (c *counter) Add(n int) {
	c.Lock()
	defer c.Unlock()
	// If the insert is successful, increment the count
	c.count += n
}

func (c *counter) Count() int {
	c.Lock()
	defer c.Unlock()
	return c.count
}
